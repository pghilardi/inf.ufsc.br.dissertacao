\chapter{Especificação e Modelagem de Sistemas Orientados a Aspectos}Este capítulo apresenta primeiramente o Perfil UML para especificação de sistemas orientados a aspectos. Este perfil fornece subsídios para realizar amodelagem e a composição automática de modelos núcleo com modelos entrecortantes. A ferramenta que realiza a composição de modelos, o algoritmo e ovisualizador de aspectos são apresentados no fim deste capítulo.\section{Especificação de Sistemas Orientados a Aspectos}O meta-modelo padrão da UML não permite a especificação de todas as características de sistemas orientados a aspectos. Este trabalho define um perfilUML que estende a linguagem com novas construções, permitindo a modelagem de sistemas que utilizam aspectos. Esta seção descreve osestereótipos, valores rotulados e restrições propostas por este perfil e também apresenta uma abordagem para representação das características estruturais ecomportamentais de aspectos, fornecendo subsídios para composição automática de modelos de aspectos com modelos núcleo do sistema. A figura\ref{fig:uml_profile} apresenta o perfil UML proposto para representar a estrutura e o comportamento de aplicações orientadas a aspectos.Este perfil pode ser utilizado em ferramentas CASE que suportem a importação de perfis através do padrão XML Metadata Interchange (XMI) para troca demeta-dados via Extensible Markup Language (XML). \subsection{Especificação Estrutural}Para modelagem estrutural, este trabalho utiliza algumas definições do trabalho proposto por Evermann \cite{Evermann:2007:MSP:1229375.1229379}, o qualpermite a representação das características estruturais de aspectos. As definições usadas do perfil de Evermann são os estereótipos \textit{CrosscuttingConcern} e \textit{Aspect}, que estão com o fundo bege no diagrama de perfil da figura\ref{fig:uml_profile}. Um estereótipo estende um elemento do meta-modelo da UML, adicionando uma nova semântica a um elemento do modelo. Nestetrabalho, um elemento do meta-modelo a ser estendido é representado dentro de parênteses. O estereótipo \textit{CrosscuttingConcern} estende(\textit{Package}) e contém um conjunto de classes e aspectos, representando um interesse que impacta uma ou mais partes de um sistema. O estereótipo\textit{Aspect} estende (\textit{Class}), contém declarações inter-tipos (introduções) e algumas propriedades de configuração como: tipo deinstanciação de um aspecto, ponto de corte associado e uma variável de controle para informar se o aspecto é privilegiado ou não. As declaraçõesinter-tipos permitem a injeção de membros (métodos, atributos) em uma classe, mudanças de hierarchia de herança entre classes e de implementação deinterfaces. Para representar declarações inter-tipos, foi proposto o estereótipo \textit{ClassExtension}. Este estereótipo estende (\textit{Class}) eestá associado a outro estereótipo denominado \textit{Introduction}. O estereótipo \textit{Introduction} é usado para marcar quais membros estão sendoinseridos em uma classe, ou qual relacionamento de herança está sendo adicionado ou removido, ou qual interface está sendo implementada. O estereótipo\textit{Introduction} estende os elementos do meta-modelo (\textit{Attribute}), (\textit{Operation}), (\textit{Generalization}) e(\textit{Realization}).\begin{figure}[!h] \centering	\includegraphics{img/full_profile.png}	\caption{Perfil UML para Modelagem de Sistemas Orientados a Aspectos.}\label{fig:uml_profile}\end{figure}Com os estereótipos propostos e o diagrama de classes da UML é possível representar a estrutura de aplicações orientadas a aspectos usandopacotes, classes e aspectos. O exemplo da figura \ref{fig:structural_profile_example} mostra como modelar um interesse entrecortante usando o perfilUML proposto por esta dissertação. Alguns dos exemplos apresentados são baseados no sistema de gerenciamento de hotéis proposto por Jacobson paraapresentar sua proposta de modelagem \cite{Jacobson:2004:ASD:1062430}. O interesse sendo modelado é a capacidade de um objeto ter seu estado copiadopara outro objeto. A funcionalidade \textit{Copyable} é especificada como um interesse entrecortante que contém o aspecto\textit{CopyableAspect}, duas extensões de classes e a definição da interface \textit{ICopyable}. As classes \textit{Room} e \textit{Reservation}são marcadas com o estereótipo \textit{ClassExtension}, para sinalizar que estão sendo estendidas pelo aspecto. A primeira extensão adicionada asclasses é a implementação da interface \textit{ICopyable}, que define dois métodos para um objeto ter a capacidade de ser copiável. Como a interface\textit{ICopyable} exige a implementação de dois métodos, o aspecto introduz os métodos \textit{copy()} e \textit{deepCopy()} nas classes \textit{Room} e \textit{Reservation}. A realização da interface \textit{ICopyable} em ambas as classes e os métodos introduzidos são marcados com o estereótipo \textit{Introduction}.\begin{figure}[!h] \centering	\includegraphics{img/structural_profile_example.png}	\caption{Exemplo de Modelagem Estrutural: Interesse Entrecortante \textit{Copyable}.}\label{fig:structural_profile_example}\end{figure}\subsection{Especificação Comportamental}Além da especificação estrutural, com declarações inter=tipos e configurações de instancialização, deve-se especificar o comportamento de um aspecto.Um aspecto é composto por pontos de corte e avisos, os quais definem em quais pontos e qual comportamento estenderá um sistema. O perfil de Evermann \cite{Evermann:2007:MSP:1229375.1229379} representa pontos de corte dentro da própria especificação de aspecto, isto é, na representação estrutural deum aspecto com classes. Esta forma de especificação não permite a captura de múltiplos pontos de junção em um mesmo ponto de corte, poisapenas outros elementos do modelo UML podem ser selecionados. A abordagem proposta nesta dissertação representa pontos de corte com o diagrama de máquina de estados da UML. Cada transição representa a captura de um ou mais pontos de junção, com a possibilidade de uso de expressões regulares(\textit{wildcards}) para captura de múltiplos pontos de execução em uma mesma construção. Se a captura de todos os pontos de junção for satisfeita, isto é, se as condições para disparar uma transição forem satisfeitas, considera-se que o sistema satisfez um ponto de corte. A composiçãode pontos de corte é realizada através da composição de diferentes máquinas de estado. No perfil proposto, o estereótipo \textit{StatePointcut} estende (\textit{State}) e representa um ponto de corte. A definição deste estereótipo pode ser visualizada na figura \ref{fig:uml_profile}.A figura \ref{fig:pointcut_definition_1} mostra um exemplo de definição de um ponto de corte. O ponto de corte \textit{AnyCall} captura chamadas(ponto de corte do tipo \textit{call}) a qualquer método, de qualquer classe, usando uma expressão regular (\textit{wildcard}) para capturar qualquertipo de retorno, qualquer classe e qualquer nome de método com qualquer número de parâmetros. O ponto de corte \textit{RoomTarget} captura a ocorrência de uma chamadaquando o objeto alvo (ponto de corte do tipo \textit{target}) é do tipo \textit{Room}. Cada ponto de corte é representado como um estado no diagramade máquina de estados. A assinatura de um ponto de corte é especificada na transição que leva ao estado do ponto de corte, a qual permite o uso de\textit{wildcards} para capturar múltiplos pontos de junção. Quando um ponto de corte é satisfeito, significa que o sistema capturou os pontos de execução especificados pela assinatura do ponto de corte.\begin{figure}[h]	\centering	\includegraphics{img/pointcut_definition_1.png}	\caption{Definição de Dois Pontos de Corte.}\label{fig:pointcut_definition_1}\end{figure}A linguagem AspectJ permite a composição de pontos de corte com os operadores lógicos \textit{and} e \textit{or}. A abordagem proposta nestadissertação realiza a composição automática de pontos de corte usando o diagrama de máquina de estados. A figura \ref{fig:pointcut_definition_and}apresenta a composição dos pontos de corte \textit{AnyCall} e \textit{RoomTarget} usando o operator \textit{and}. A máquina de estado composta contémum estado com uma região concorrent, contendo sub-estados que executam concorrentemente: \textit{AnyCall} e \textit{RoomTarget}. A sincronizaçãoocorre com os nodos \textit{fork} e \textit{join}, os quais garantem que o estado final (\textit{AnyCall AND RoomTarget}) somente será satisfeito seambos os estados (\textit{AnyCall} e \textit{RoomTarget} forem satisfeitos. Esta é a semântica do operador \textit{and} na linguagem AspectJ. A figura\ref{fig:pointcut_definition_or} apresenta a composição de pontos de corte usando o operador \textit{or}. Neste caso a semântica é um pouco diferente,porque o sistema alcançara o estado final (\textit{AnyCall OR RoomTarget}) quando qualquer um dos pontos de corte for satisfeito. Este comportamento érepresentado na máquina de estados composto, que contém transições diretas de ambos estados para o estado final.\begin{figure}[h]	\centering	\includegraphics{img/pointcut_definition_and.png}	\caption{A composição de dois pontos de corte com o operador AND.}\label{fig:pointcut_definition_and}\end{figure}\begin{figure}[h]	\centering	\includegraphics{img/pointcut_definition_or.png}	\caption{A composição de dois pontos de corte com o operador OR.}\label{fig:pointcut_definition_or}\end{figure}Um ponto de corte captura somente os pontos de execução de um sistema. O comportamento que deve ser injetado nestes pontos é representado pelo aviso,o qual está diretamente associado a um ponto de corte. Diagramas de sequência são utilizados para representar o comportamento dos interesses núcleo(modelo núcleo) e dos interesses entrecortantes (modelos entrecortantes). Um aspecto pode conter um ou mais avisos e cada um é representado por ummodelo entrecortante. O comportamento de um aviso executa quando os pontos de corte associados ao mesmo são satisfeitos, isto é, todos os pontos dejunção são capturados. Como nesta dissertação pontos de corte são modelados com o diagrama de máquina de estados e avisos com o diagrama de sequência,a conexão entre avisos com pontos de corte deve ser realizada utilizando elementos sintáticos destes diagramas. A conexão entre estes elementos érealizada através do uso de invariantes de estado. Uma invariante de estado é um fragmento de interação associado com a linha de vida de um diagramade sequência, representado uma restrição em tempo de execução nos participantes da interação. A alcançabilidade de um estado é usado como restriçãopara disparar a execução de um aviso. A definição de um modelo entrecortante (como um diagrama de sequência) inicia adicionando o aspecto como o objeto associado a primeira linha de vidado diagrama. Uma invariante de estado, a qual representa a satisfação do ponto de corte, é associada a linha de vida do aspecto. Isto significa que asequência de mensagens ocorrerá somente quando o sistema atingir o estado representado pela invariante de estado. As mensagens podem ser executadosantes, durante ou depois do disparo do ponto de corte. O tempo de execução das mensagens adicionadas pelo aspecto é configurado usando o estereótipo\textit{AdviceExecutionType}. Este estereótipo estende (\textit{StateInvariant}) e é apresentado na parte inferior da figura \ref{fig:uml_profile}. Oestereótipo \textit{AdviceExecutionType} tem um valor rotulado do tipo enumeração denominado de \textit{adviceType}. Os tipos válidos para este enumerável são:antes, durante ou depois.A conexão entre avisos e pontos de corte pode ser melhor compreendida no exemplo da figura \ref{fig:behavioral_profile_example}. A figura\ref{fig:behavioral_profile_example} apresenta o ponto de corte previamente especificado para captura de chamadas (ponto de corte \textit{call}) dequalquer método em qualquer classe com qualquer número de parâmetros (\textit{AnyCall}). O aspecto de registro de mensagens (\textit{log}) define ummodelo entrecortante que registra uma mensagem usando uma classe do tipo \textit{Logger}. O modelo entrecortante é descrito como uma sequência demensagens em uma diagrama de sequência. Este diagrama contém uma invariante de estado que referencia o ponto de corte \textit{AnyCall}. Uma invariantede estado deve ter o estereótipo \textit{AdviceExecutionType} e o valor rotulado \textit{adviceType} para especificar quando o comportamento do avisoserá executado. No exemplo, o comportamento do aspecto será eecutado depois (\textit{after}) dos pontos de junção capturados pelo ponto de corte\textit{AnyCall}. A mensagem \textit{log()} será executada somente quando o estado \textit{AnyCall} for satisfeito.\begin{figure}[h]	\centering	\includegraphics{img/behavioral_profile_example.png}	\caption{A conexão entre pontos de corte e avisos usando invariantes de estado.}\label{fig:behavioral_profile_example}\end{figure}\section{Visualização e Composição Automatizada de Aspectos}Esta seção apresenta a ferramenta \textit{SEA/Aspect} que é um dos produtos desta dissertação, a qual permite a visualização de modelos entrecortantescompostos com modelos núcleo utilizando diagramas de classe e de sequência. O algoritmo para composição de modelos é descrito em passos pararealizar a composição de classes e de mensagens. Finalmente, o visualizador de aspectos é apresentado.\subsection{A Ferramenta SEA/Aspect}O perfil UML proposto fornece subsídios para composição e visualização dinâmica de aspectos. O perfil foi adicionado no ambiente de desenvolvimentoSEA \cite{silva:00}, o qual suporta a diagramação e modelagem UML. A ferramenta SEA/Aspect permite a seleção de quais modelos entrecortantes serãocompostos com os modelos núcleo do sistema. Um desenvolvedor pode automaticamente visualizar somente os modelos núcleo, os modelos entrecortantes, ouos modelos núcleo compotos com os entrecortantes. Aspectos podem ser habilitados ou desabilitados dinamicamente, atualizando o modelo composto. Estaatualização automática permite a mudança de visões, visualizando diferentes composições de modelos.A composição de modelos da ferramenta SEA/Aspect tem dois passos para produzir um modelo composto: \textbf{seleção} e \textbf{composição},as quais são descritas nas próximas duas seções. A fase de seleção deve ser executada manualmente pelo desenvolvedor, enquanto a fase de composição éexecutada automaticamente pelo algoritmo de composição do ambiente SEA.\subsubsection{Seleção}  Nesta etapa o desenvolvedor seleciona manualmente quais modelos núcleo e entrecortantes deseja compor atribuindo uma cor diferente para cada modelo.Estas cores diferenciam os elementos de cada modelo no modelo composto. As mensagens enviadas pelos objetos de cada modelo serão preenchidas com a corassociada ao modelo em questão. A figura \ref{fig:selection_screen} apresenta a janela para seleção de aspectos na ferramenta SEA/Aspect. Nesteexemplo é possível visualizar três modelos entrecortantes: lista de espera (\textit{Waiting List}), registro de mensagens (\textit{Log}) eprograma de fidelidade (\textit{Earn Loyalty Points}) e um modelo núcleo: reserva de quarto (\textit{ReserveRoom}). Nesta seleção, o desenvolvedordeseja visualizar a composição entre os modelos \textit{ReserveRoom}, \textit{Waiting List} e \textit{Log}.  \begin{figure}[!h]	\centering	\includegraphics{img/selection_screen.png}	\caption{Seleção de Modelos Para Composição.}\label{fig:selection_screen}  \end{figure}  Os modelos núcleo e entrecortantes selecionados pelo desenvolvedor são utilizados como entrada da etapa de composição, que, basedo nos pontos de cortee nas introduções dos modelos entrecortantes selecionará quais elementos devem ser modificados no modelo composto.  \subsubsection{Composição}A composição é realizada entre um modelo núcleo e um ou mais modelos entrecortantes, provendo como resultado um modelo composto com a estrutura ou ocomportamento dos modelos entrecortantes injetados no modelo núcleo. No modelo composto, o comportamento entrecortante diferencia-se do comportamentonúcleo pelas cores diferentes, como pode ser visualizado na figura \ref{fig:case_study_compound_2}, que mostra a composição de diagrama desequência entre os interesses de lista de espera, reserva de quarto e registro de mensagens de um sistema.O meta-modelo do ambiente de desenvolvimento SEA é utilizado para composição de modelos. Os principais elementos do meta-modelo podem ser visualizadosno diagrama da figura \ref{fig:sea_meta_model}. No meta-modelo do SEA, uma especificação (\textit{Specification}) agrega um conjunto de elementos deespecificação (\textit{SpecificationElement}), os quais podem ser modelos (\textit{ConceptualModel}) ou conceitos (\textit{Concept}). Estes modelosde especificação podem ser associados com dois tipos de relacionamento: sustentabilidade (\textbf{sustainment}) e referência (\textbf{reference}). Orelacionamento de sustentabilidade estabelece uma relação semântica entre dois elementos, quando um assume o papel de sustentado e o outro desustentador. A semântica desse relacionamento é que o elemento sustentado existirá em uma especificação enquanto o elemento sustentador existir.Um exemplo de relacionamento de sustentabilidade é o relacionamento entre classes, atributos e métodos, no qual uma classe é o sustentador e seuscampos são sustentados pela classe. O relacionamento de referência estabelece que elementos referenciadores dependem de um elemento referenciado. Umexemplo deste tipo de relacionamento é uma mensagem em um diagrama de sequência, que depende de um método de uma determinada classe. Se o método forremovido da especificação, a mensagem ainda existirá, mas sua semântica estará incompleta.É possível realizar um mapeamento do meta-modelo do ambiente SEA para o meta-modelo da UML. Cada elemento do meta-modelo da UML é representado por umconceito e os diagramas da UML são os modelos. Um diagrama da UML contém um conjunto de elementos, os quais podem estar associados. Na linguagem doSEA, um modelo contém um cojunto de conceitos com relacionamentos de referência ou sustentabilidade. Por exemplo, o diagrama de classe é um modelo quecontém conceitos como classe, atributos e métodos. O diagrama de sequência também é um modelo e contém conceitos como linhas de vida, mensagens,invariantes de estado, etc.  \begin{figure}[!h]	\centering	\includegraphics{img/sea_meta_model.png}	\caption{SEA meta-model.}\label{fig:sea_meta_model}  \end{figure}  Com o meta-modelo para composição é necessário uma classe que implemente o algoritmo de composição: a classe \textit{AspectComposer}. O algoritmo decomposição tem duas atividades: \textbf{match} e \textbf{merge}. A primeira atividade localiza os conceitos selecionados no modelo núcleo pelos pontosde corte ou introduções definidas nos modelos entrecortantes. A atividade de \textit{merge} injeta a estrutura ou o comportamento dos modelosentrecortantes no modelo núcleo, fornecendo como resultado um modelo composto. A ferramenta SEA/Aspect permite a composição automática de diagramas declasse e de sequência.A composição de diagramas de classe faz uma comparação por nome para selecionar os elementos impactados e tem os seguintes passos:  \begin{itemize}  	\item \textbf{Comparação e Seleção:} Utiliza uma estratégia que compara diretamente o nome entre aspectos, classes, atributos e métodos. O algoritmo	procura por elementos que estejam associados com o estereótipo \textit{ClassExtension} nos modelos entrecortantes. Um conceito marcado com este	estereótipo contém introduções (com o estereótipo \textit{Introduction}) para serem adicionadas em outros conceitos. Essas introduções podem ser a	adição de campos (métodos ou atributos), mudança na hierarquia de herança ou a implementação de uma interface. 		\item \textbf{Composição:} Quando os conceitos impactados são localizados, o compositor executa uma operação de composição entre os modelos	entrecortantes e o modelo núcleo. Esta composição produz um modelo composto com os campos, relacionamentos de generalização e realização	adicionados aos conceitos impactados no modelo núcleo. Esta operação de composição é realizada utilizando o meta-modelo do ambiente SEA, o qual	permite a adição, remoção e modificação de relacionamentos entre conceitos dinamicamente.\end{itemize}A figura \ref{fig:structural_composition_example} apresenta um modelo composto originado pela composição de dois modelos estruturais (diagramas declasse). O primeiro diagrama é modelado na figura \ref{fig:structural_profile_example} e apresenta o interesse entrecortante que adiciona afuncionalidade de um objeto ter seu estado copiado para outro objeto utilizando a interface \textit{ICopyable}. O interesse núcleo é modelado pelo diagrama na figura\ref{fig:structural_core_concern_class_diagram} e modela a estrutura de classes necessária para realizar a reserva de um quarto de hotel. Estemodelo contém a classe \textit{Room} com o método \textit{updateAvailability()} e a classe \textit{ReserveRoomHandler} com ométodo \textit{makeReservation()}. O algoritmo de composição de diagrama de classes começa selecionando elementos do modelo núcleo que sãoimpactados pelos modelos entrecortantes (comparação direta por nome). Neste primeiro filtro verifica-se que somente a classes \textit{Room} e\textit{Reservation} está presente em ambos os modelos, logo, esta classe pode ter alguma mudança na sua estrutura. Verifica-se que a classe\textit{Room} está marcada com o estereótipo \textit{ClassExtension}, o que significa que a mesma sofrerá a introdução de algum membro presenteno modelo entrecortante. O próximo passo do algoritmo é buscar por estereótipos do tipo \textit{Introduction}. Ao executar este passo, seis estereótipos são encontrados, sendo dois adicionando um relacionamento de realização de interface entre as classes \textit{Room} e \textit{Reservation} com a novainterface \textit{ICopyable} e quatro estereótipos adicionando os métodos \textit{copy()} e \textit{deepCopy()} nas classes \textit{Room} e\textit{Reservation}. Neste exemplo de composição, apenas a classe \textit{Room} será modificada pelas introduções do modelo entrecortante. Ao final,o modelo composto contém a classe \textit{Room} com dois novos métodos: \textit{copy()} e \textit{deepCopy()} e implementando a interface\textit{ICopyable}. A classe \textit{ReserveRoomHandler} não foi modificada com a composição.  \begin{figure}[!h]	\centering	\includegraphics{img/structural_core_concern_class_diagram.png}	\caption{Modelo núcleo para reserva de quarto.}\label{fig:structural_core_concern_class_diagram}  \end{figure}      \begin{figure}[!h]	\centering	\includegraphics{img/structural_composition_example.png}	\caption{Composição do modelo núcleo com o modelo entrecortante para cópia de estado entre objetos	(\textit{Copyable}).}\label{fig:structural_composition_example}  \end{figure}A composição de diagramas de sequência realiza a comparação entre conceitos utilizando expressões regulares (\textit{wildcard matching}) e tem osseguintes passos:  	\begin{itemize}	  	  \item \textbf{Comparação e Seleção:} Com os modelos núcleo e entrecortantes selecionados pelo desenvolvedor, o algoritmo de composição busca pelos	  pontos de junção do modelo núcleo que são impactados pelos modelos entrecortantes. Esta informação é obtida pelos pontos de corte definidos nos	  modelos entrecortantes. Esta busca pode ser separada em três passos:	  	  \begin{enumerate}	    \item \textbf{Find the pointcut:} To obtain the pointcut from the	    crosscutting sequence diagram (crosscutting model), the algorithm looks for the state invariants 	    stereotyped as \textit{AdviceExecutionType}. The state invariant maps to	    the state that defines the pointcut.	    \item \textbf{Separate the pointcut:} The composer uses a regular		   expression to separate a pointcut in four parts: \textbf{pointcut type}, \textbf{return type pattern},		  \textbf{identification pattern} and \textbf{exception pattern}. 		  The pointcut type is mandatory and is one of the types supported by the		  AspectJ language, which includes \textit{execution}, \textit{call}, 		  \textit{this} and others. The return type pattern is optional and specifies the return		  type of the pointcut. The identification pattern is mandatory and contains		  the signature to be matched in the core model. Finally, the exception pattern		  is optional too, and is used to capture execution points that throws		  exceptions of a given type	    	    \item \textbf{Match the execution points:} The composer uses regular		    expressions to match which execution points are impacted by the pointcuts defined in the crosscutting 		  models. This match support pointcuts specified with wildcards, that is an		  important feature of aspect-oriented languages. It starts using the		  identification pattern to find context information about the impacted 		  concepts, like package and class context of a given method, for example. 		  When all concepts inside a given context are captured, the algorithm uses		  another regular expression to match the names of the captured concepts. 		  For instance, when matching a method, the algorithm check return type,		  parameters (name, type and number of parameters) and the method signature. 		  Finally, the composer check for exception throws, if any. As output, the		  concepts (classes and methods) impacted by the crosscutting models are		  stored to be used in the merge activity.	  \end{enumerate}  	  	  \item \textbf{Merge:} Merge concepts of the crosscutting models with	  the impacted core model concepts. The merge receives as input the impacted	  core model concepts that should be merged with croscutting ones. The merge	  purpose is to inject a set of messages, lifelines, combined fragments and	  other sequence diagram concepts in the core sequence diagram (core model),	  adding new behavior defined in the crosscutting sequence diagrams	  (crosscutting models). To achieve this, the algorithm is separated in	  two steps:		  \begin{enumerate}		    		    \item \textbf{Find the advice execution type:} Retrieve the advice execution type from the		    state invariant defined by the crosscutting model. The supported advice		    types are: \textit{before}, \textit{around} and \textit{after} and are defined in 		    the tagged value advice type. The advice type gives the		    information of when the messages should be injected in the core sequence diagram.		  			  	\item \textbf{Inject the messages:} At this time, the algorithm knows the		  	impacted concepts, the messages to inject from the crosscutting model 		  	and when the messages should be inserted. The next		  	step is the messages injection and reordering, because the injection of a		  	message triggers a reordering event in the sequence diagram. With all		  	the messages injected and ordered, the composer paints each message name		  	with the correspondent crosscutting model color, to differentiate which		  	message comes from which aspect. The merge produces as output a compound		  	sequence diagram with the crosscutting concepts composed in the core		  	sequence diagram.		  		  \end{enumerate}		  	  \end{itemize}  	  \subsubsection{Conflitos e Ordem de Composição}A composição de modelos núcleo com modelos entrecortantes pode gerar conflitos e diferentes resultados dependendo da ordem de composição. Por isso, aordem de composição é definida pela \ldots	  \subsubsection{Visualization Toggling}Besides aspect composition, the SEA/Aspect tool allows to toggle themodels that are being visualized dynamically, without effort from thedeveloper, by using a model selector. A compound model with the selector at the bottom right can be viewed in the figure \ref{fig:case_study_compound_1}. Visualizing the aspect behavior into the core functionality facilitates theunderstanding and maintenance of an aspect-oriented system in the earlydevelopment phases. One of the obstacles for using aspect-oriented approaches isthe difficulty of understanding a system, since it is difficult to understand the execution flow without any additional tools. The visualizer should be usedat the modeling phase, allowing the understanding of the system at a higher level of abstractionthan the code. The visualizer is show in details in the next section, thatpresents a case study using the proposed approach.